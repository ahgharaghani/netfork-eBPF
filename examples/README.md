# eBPF Container Firewall Examples

> **Note:** This reference implementation and architectural design were generated by **Claude Sonnet 4.6**.
>
> The purpose of releasing these codebases and configurations is to provide a comprehensive, production-ready reference point for contributors. Developers can use this code to understand how to integrate sophisticated eBPF logic (network policy, connection tracking, and event streaming) into a JavaScript-based container management stack (Node.js).

## ‚ö†Ô∏è Disclaimer

This code is **example/reference material** designed for:
- Learning eBPF programming patterns
- Understanding container network security architectures
- Serving as a starting point for production implementations

**This is NOT production-ready code**. Use it to understand concepts, adapt patterns to your needs, and build upon the ideas presented here.

---

## üìñ Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Components](#components)
  - [Common Headers](#common-headers)
  - [XDP Firewall](#xdp-firewall)
  - [TC Firewall](#tc-firewall)
  - [Cgroup Firewall](#cgroup-firewall)
  - [Rate Limiter](#rate-limiter)
  - [DNS Filter](#dns-filter)
- [How to Build](#how-to-build)
- [Usage Examples](#usage-examples)
- [Integration with JavaScript](#integration-with-javascript)
- [Extending the Code](#extending-the-code)
- [Learning Resources](#learning-resources)

---

## Overview

This repository contains a complete eBPF-based firewall system for container environments, demonstrating:

- **Multi-layer defense**: XDP ‚Üí TC ‚Üí cgroup hooks
- **Stateful connection tracking**: TCP/UDP flow state management
- **Rate limiting**: Token bucket algorithm to prevent floods
- **DNS filtering**: Query inspection and domain blocking
- **Real-time telemetry**: Ring buffer events to userspace
- **Per-container policies**: Using cgroup hierarchy for isolation

### What Problem Does This Solve?

Traditional container firewalls (iptables/nftables) struggle with:
- High packet rates (performance bottleneck)
- Per-container granularity (complex rule management)
- Observability (limited visibility into drop reasons)
- Resource overhead (kernel ‚Üí userspace context switches)

eBPF solves these by running firewall logic **in the kernel data path** with minimal overhead, while providing rich telemetry to userspace applications (like your Node.js container manager).

---

## Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Container Manager (JS)                   ‚îÇ
‚îÇ  - Loads .bpf.o files into kernel                          ‚îÇ
‚îÇ  - Writes policies to eBPF maps                            ‚îÇ
‚îÇ  - Reads stats & events from ring buffer                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   eBPF Programs in Kernel                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Layer 1: XDP (on NIC)                                      ‚îÇ
‚îÇ    ‚îú‚îÄ xdp_firewall.bpf.c                                   ‚îÇ
‚îÇ    ‚îî‚îÄ Drops blocked IPs before sk_buff allocation          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Layer 2: TC (on veth interface)                           ‚îÇ
‚îÇ    ‚îú‚îÄ tc_firewall.bpf.c                                    ‚îÇ
‚îÇ    ‚îú‚îÄ rate_limit.bpf.c                                     ‚îÇ
‚îÇ    ‚îú‚îÄ dns_filter.bpf.c                                     ‚îÇ
‚îÇ    ‚îî‚îÄ Full packet access + connection tracking             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Layer 3: Cgroup (per-container policy)                    ‚îÇ
‚îÇ    ‚îú‚îÄ cgroup_firewall.bpf.c                                ‚îÇ
‚îÇ    ‚îî‚îÄ Egress allowlisting per container                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Packet Journey

```
1. Packet arrives ‚Üí XDP hook
   ‚îú‚îÄ Blocked IP? ‚Üí DROP (fastest path)
   ‚îî‚îÄ Pass to network stack

2. sk_buff allocated ‚Üí TC ingress hook
   ‚îú‚îÄ Rate limit exceeded? ‚Üí DROP
   ‚îú‚îÄ DNS query to blocked domain? ‚Üí DROP
   ‚îú‚îÄ Established connection? ‚Üí PASS (fast path via conntrack)
   ‚îú‚îÄ New connection matches rule? ‚Üí PASS + track
   ‚îî‚îÄ No rule? ‚Üí DROP (default deny)

3. Packet reaches container's cgroup ‚Üí cgroup_skb hook
   ‚îú‚îÄ Destination in egress allowlist? ‚Üí PASS
   ‚îî‚îÄ Not allowed? ‚Üí DROP

4. All checks passed ‚Üí packet delivered to container process
```

---

## Components

### Common Headers

#### `common.h`

Shared data structures and packet parsing logic used by all programs.

**Key structs**:
- `struct packet_info` ‚Äî parsed packet (IP, ports, protocol, flags)
- `struct five_tuple` ‚Äî connection identifier (used as map keys)
- `struct fw_event` ‚Äî telemetry events sent to userspace

**Key functions**:
- `parse_packet()` ‚Äî extracts headers from sk_buff
- `parse_packet_xdp()` ‚Äî XDP variant (no sk_buff available)
- `fnv1a_hash()` ‚Äî domain name hashing for DNS filter

#### `maps.h`

All eBPF maps shared across programs.

| Map | Type | Purpose |
|-----|------|---------|
| `blocked_ips` | HASH | Global IP blocklist |
| `fw_rules` | HASH | 5-tuple firewall rules |
| `conntrack` | LRU_HASH | Connection state tracking |
| `container_policies` | HASH | Per-container default policy |
| `pkt_stats` | PERCPU_HASH | Packet counters (lock-free) |
| `rate_limiter` | LRU_HASH | Token buckets for rate limiting |
| `blocked_domains` | HASH | DNS domain blocklist (hashed) |
| `fw_events` | RINGBUF | Event stream to userspace |
| `egress_allowlist` | HASH | Allowed destinations per container |

---

### XDP Firewall

**File**: `xdp_firewall.bpf.c`

**Attach point**: Network interface (before sk_buff allocation)

**Purpose**: Drop malicious packets at the earliest possible point

**Logic**:
1. Parse Ethernet ‚Üí IP ‚Üí TCP/UDP headers
2. Check `blocked_ips` map
3. Drop if matched, otherwise pass to network stack

**When to use**:
- Protecting against DDoS from known bad IPs
- Reducing CPU usage by dropping before memory allocation

**Example**:
```c
// Block all traffic from 192.0.2.100
u32 bad_ip = 0x6400C0C0; // network byte order
u8  reason = REASON_BLOCKLIST;
bpf_map_update_elem(&blocked_ips, &bad_ip, &reason, BPF_ANY);
```

---

### TC Firewall

**File**: `tc_firewall.bpf.c`

**Attach point**: Traffic Control (tc) ingress/egress on veth

**Purpose**: Stateful firewall with connection tracking

**Logic**:
1. Check if packet belongs to established connection (conntrack lookup)
   - If yes ‚Üí fast path, update timestamp, allow
2. Check IP blocklist
3. Check 5-tuple firewall rules
4. Check container default policy
5. If allowed, insert into conntrack for future fast-path

**Connection tracking**:
- Tracks TCP/UDP flows
- Removes entries on FIN/RST
- Uses LRU map so old connections are auto-evicted

**Example flow**:
```javascript
// JS side: allow container to connect to 1.1.1.1:443
const rule = {
  src_ip: containerIP,
  dst_ip: ipToInt('1.1.1.1'),
  dst_port: 443,
  proto: IPPROTO_TCP,
  action: ACTION_ALLOW,
  container_id: cgroupId
};
maps.fw_rules.set(rule.five_tuple, rule);
```

First packet ‚Üí slow path (rule lookup)  
Subsequent packets ‚Üí fast path (conntrack hit)

---

### Cgroup Firewall

**File**: `cgroup_firewall.bpf.c`

**Attach point**: Container's cgroup (ingress/egress)

**Purpose**: Per-container egress policy enforcement

**Why separate from TC?**
- Cgroup attachment = automatic container membership detection
- No need to track which veth belongs to which container
- Survives container restarts (cgroup path stays same)

**Egress logic**:
1. Get container's cgroup_id
2. Check if destination is in `egress_allowlist`
3. Allow only if explicitly permitted (default deny)

**Example ‚Äî lock down container to only contact specific IPs**:
```javascript
// Only allow DNS and HTTPS to specific servers
const allowed = [
  { ip: '8.8.8.8',    port: 53,  proto: UDP },
  { ip: '1.1.1.1',    port: 443, proto: TCP },
  { ip: '10.0.0.5',   port: 443, proto: TCP }
];

allowed.forEach(endpoint => {
  maps.egress_allowlist.set(endpoint, 1);
});
```

Container can now **only** talk to those endpoints. Everything else is dropped.

---

### Rate Limiter

**File**: `rate_limit.bpf.c`

**Attach point**: TC ingress

**Purpose**: Protect against floods (SYN, UDP, ICMP)

**Algorithm**: Token bucket
- Each source IP gets a bucket of tokens
- Tokens refill at a fixed rate (10ms per token)
- Each packet consumes 1 token
- No tokens = drop packet

**What gets rate limited**:
- TCP SYN packets (new connections)
- UDP packets
- ICMP packets

**What does NOT get rate limited**:
- Established TCP connections (packets with ACK flag)

**Example ‚Äî detect port scan**:
```
Attacker scans 10,000 ports in 1 second:
- 10,000 SYN packets
- Rate limit = 100 tokens max
- Result: first 100 SYNs pass, rest are dropped
- Event emitted to userspace with REASON_RATE_LIMIT
```

**Tuning** (in `common.h`):
```c
#define RATE_LIMIT_BURST         100   // max tokens
#define RATE_LIMIT_NS_PER_TOKEN  10000000ULL  // 1 token per 10ms = 100 pkt/sec
```

---

### DNS Filter

**File**: `dns_filter.bpf.c`

**Attach point**: TC ingress (intercepts outgoing DNS queries)

**Purpose**: Block DNS queries to forbidden domains

**How it works**:
1. Detect UDP port 53 (DNS)
2. Parse DNS query name from packet payload
3. Hash domain name with FNV-1a
4. Look up hash in `blocked_domains` map
5. Drop if match

**DNS wire format parsing**:
```
DNS query: www.example.com
Wire format: 3www7example3com0

The code walks this label-length encoding and
converts it to "www.example.com", then hashes it.
```

**Example**:
```javascript
// Block ads and malware domains
const blocklist = [
  'ads.google.com',
  'malware.evil.net',
  'tracker.analytics.io'
];

blocklist.forEach(domain => {
  const hash = fnv1a(domain);
  maps.blocked_domains.set(hash, 1);
});
```

**Note on hash collisions**: FNV-1a is a non-cryptographic hash. Collisions will cause false positives (blocking innocent domains). For production, use a Bloom filter or full string matching.

---

## How to Build

### Prerequisites

```bash
# Ubuntu/Debian
sudo apt install -y \
  clang \
  llvm \
  libbpf-dev \
  linux-tools-common \
  linux-tools-$(uname -r) \
  linux-headers-$(uname -r)

# Fedora/RHEL
sudo dnf install -y clang llvm libbpf-devel bpftool kernel-devel

# Arch
sudo pacman -S clang llvm libbpf bpf linux-headers
```

### Build Commands

```bash
cd ebpf/
make

# output:
# [OK] clang   : /usr/bin/clang (clang version 14.0.0)
# [OK] bpftool : /usr/sbin/bpftool
# [OK] headers/vmlinux.h ‚Äî 89421 lines
# [CC] src/xdp_firewall.bpf.c ‚Üí compiled/xdp_firewall.bpf.o
# ... (all programs compiled)
```

### Verify

```bash
# inspect compiled object
llvm-objdump -S compiled/tc_firewall.bpf.o

# dry-run load (doesn't actually attach)
bpftool prog load compiled/tc_firewall.bpf.o /dev/null
```

---

## Usage Examples

### 1. Load and Attach XDP Firewall

```bash
# load program
sudo bpftool prog load \
  compiled/xdp_firewall.bpf.o \
  /sys/fs/bpf/xdp_fw

# attach to interface
sudo bpftool net attach xdp \
  dev eth0 \
  pinned /sys/fs/bpf/xdp_fw

# verify attachment
sudo bpftool net show dev eth0
```

### 2. Add Blocked IP

```bash
# get map id
MAP_ID=$(sudo bpftool map show | grep blocked_ips | awk '{print $1}' | cut -d: -f1)

# block 192.0.2.50
sudo bpftool map update id $MAP_ID \
  key 0x32 0x00 0x00 0xC0 \
  value 0x01

# verify
sudo bpftool map dump id $MAP_ID
```

### 3. Attach TC Firewall to Container

```bash
# identify container's veth
CONTAINER_ID=abc123
VETH=$(sudo docker exec $CONTAINER_ID cat /sys/class/net/eth0/iflink)
VETH_NAME=$(ip link | grep "^$VETH:" | awk '{print $2}' | cut -d@ -f1)

# create tc clsact qdisc
sudo tc qdisc add dev $VETH_NAME clsact

# attach ingress
sudo tc filter add dev $VETH_NAME ingress \
  bpf obj compiled/tc_firewall.bpf.o sec tc_ingress_firewall \
  direct-action

# attach egress
sudo tc filter add dev $VETH_NAME egress \
  bpf obj compiled/tc_firewall.bpf.o sec tc_egress_firewall \
  direct-action
```

### 4. Attach Cgroup Firewall

```bash
# find container's cgroup path
CGROUP_PATH=$(docker inspect -f '{{.HostConfig.CgroupParent}}' $CONTAINER_ID)

# load program
sudo bpftool prog load compiled/cgroup_firewall.bpf.o /sys/fs/bpf/cgroup_fw

# attach egress
sudo bpftool cgroup attach \
  /sys/fs/cgroup/$CGROUP_PATH \
  egress \
  pinned /sys/fs/bpf/cgroup_fw

# verify
sudo bpftool cgroup tree /sys/fs/cgroup/$CGROUP_PATH
```

### 5. Read Stats

```bash
# dump packet counters map
sudo bpftool map dump name pkt_stats --json | jq

# example output:
[{
  "key": ["0x1a2b3c4d5e6f7081"],  // cgroup_id
  "values": [{
    "cpu": 0,
    "value": {
      "rx_packets": 1523,
      "tx_packets": 1489,
      "rx_bytes": 204812,
      "tx_bytes": 98234,
      "dropped": 42,
      "rate_limited": 8
    }
  }]
}]
```

### 6. Stream Events to Userspace

```bash
# poll ring buffer (blocks, prints events as they arrive)
sudo bpftool map event_pipe name fw_events

# example event:
{
  "timestamp_ns": 1634567890123456789,
  "cgroup_id": "0x1a2b3c4d",
  "src_ip": "192.168.1.100",
  "dst_ip": "1.1.1.1",
  "dst_port": 443,
  "proto": 6,
  "action": 0,  // DROP
  "reason": 1   // BLOCKLIST
}
```

---

## Integration with JavaScript

### Node.js Example

```javascript
// src/ebpf/firewall.ts
import { createRequire } from 'module';
const libbpf = createRequire(import.meta.url)('../../native/build/addon.node');

export class EbpfFirewall {
  private programs = new Map();

  loadXdpFirewall(iface: string) {
    const fd = libbpf.load('ebpf/compiled/xdp_firewall.bpf.o');
    libbpf.attachXdp(fd, iface);
    this.programs.set('xdp', fd);
  }

  blockIP(ip: string) {
    const ipInt = ipToNetworkOrder(ip);
    libbpf.mapUpdate(this.programs.get('xdp'), 'blocked_ips', ipInt, 1);
  }

  onEvent(callback: (event: FirewallEvent) => void) {
    libbpf.ringbufPoll(this.programs.get('xdp'), 'fw_events', (raw) => {
      callback(parseEvent(raw));
    });
  }

  getContainerStats(cgroupId: bigint): PacketStats {
    return libbpf.mapLookup(this.programs.get('tc'), 'pkt_stats', cgroupId);
  }
}
```

### Container Manager Integration

```javascript
// src/containers/manager.ts
import { EbpfFirewall } from '../ebpf/firewall';

export class ContainerManager {
  private firewall = new EbpfFirewall();

  async startContainer(id: string, policy: NetworkPolicy) {
    // start container via Docker/containerd
    await this.runtime.start(id);

    // get cgroup path
    const cgroupPath = await this.getCgroupPath(id);
    const cgroupId = await this.getCgroupId(cgroupPath);

    // attach cgroup firewall
    this.firewall.attachCgroup(cgroupPath, policy);

    // set egress allowlist
    policy.allowedDestinations.forEach(dest => {
      this.firewall.allowEgress(cgroupId, dest);
    });

    // stream events
    this.firewall.onEvent(event => {
      if (event.action === ACTION_DROP) {
        console.warn(`[${id}] blocked packet:`, event);
        this.alerts.emit('firewall-drop', { container: id, event });
      }
    });
  }

  async getContainerBandwidth(id: string) {
    const cgroupId = await this.getCgroupId(id);
    const stats = this.firewall.getContainerStats(cgroupId);
    return {
      rx: stats.rx_bytes,
      tx: stats.tx_bytes
    };
  }
}
```

---

## Extending the Code

### Add IPv6 Support

Currently only IPv4 is handled. To add IPv6:

1. **Update `parse_packet()`** in `common.h`:
```c
if (bpf_ntohs(eth->h_proto) == ETH_P_IPV6) {
    struct ipv6hdr *ip6 = (void *)(eth + 1);
    if ((void *)(ip6 + 1) > data_end) return -1;
    
    // copy src/dst addresses
    __builtin_memcpy(&pkt->src_ip6, &ip6->saddr, 16);
    __builtin_memcpy(&pkt->dst_ip6, &ip6->daddr, 16);
    pkt->proto = ip6->nexthdr;
    // ... parse transport headers
}
```

2. **Update structs** to use unions:
```c
struct packet_info {
    union {
        __u32 src_ip;      // IPv4
        __u8  src_ip6[16]; // IPv6
    };
    // ...
};
```

3. **Add IPv6 maps**:
```c
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, struct in6_addr);
    __type(value, __u8);
} blocked_ipv6 SEC(".maps");
```

### Add TLS SNI Inspection

Inspect TLS Client Hello to filter HTTPS by domain:

```c
// parse TLS record header
struct tls_hdr {
    __u8  content_type;  // 0x16 = handshake
    __u16 version;
    __u16 length;
};

// extract SNI from Client Hello
static __always_inline int
extract_sni(struct __sk_buff *skb, int offset, __u8 *domain) {
    // TLS is complex ‚Äî see reference impl:
    // https://github.com/cilium/cilium/blob/master/bpf/lib/l7.h
    
    // simplified: skip to extensions, find SNI (type 0x00)
    // ... (boundary checks required for verifier)
}
```

### Add GeoIP Blocking

Use a compressed IP‚ÜíCountry map:

```c
// map: CIDR prefix ‚Üí country code
struct {
    __uint(type, BPF_MAP_TYPE_LPM_TRIE);
    __uint(key_size, sizeof(struct lpm_key));
    __uint(value_size, 2);  // 2-char country code
    __uint(max_entries, 1000000);
    __uint(map_flags, BPF_F_NO_PREALLOC);
} geoip SEC(".maps");

struct lpm_key {
    __u32 prefixlen;
    __u32 ip;
};

// lookup country
struct lpm_key key = { .prefixlen = 32, .ip = pkt->src_ip };
__u16 *country = bpf_map_lookup_elem(&geoip, &key);

if (country && *country == 0x4E43) { // 'CN'
    return XDP_DROP;
}
```

Populate from MaxMind GeoIP database in userspace.

---

## Learning Resources

### eBPF Fundamentals
- [eBPF.io](https://ebpf.io/) ‚Äî official introduction
- [Cilium eBPF Guide](https://docs.cilium.io/en/stable/bpf/)
- [Kernel Documentation](https://www.kernel.org/doc/html/latest/bpf/)

### BPF Program Types
- [XDP Tutorial](https://github.com/xdp-project/xdp-tutorial)
- [TC BPF Examples](https://github.com/torvalds/linux/tree/master/samples/bpf)
- [Cgroup BPF](https://lwn.net/Articles/747504/)

### Connection Tracking
- [Cilium Conntrack](https://github.com/cilium/cilium/tree/master/bpf)
- [Katran (Facebook L4 LB)](https://github.com/facebookincubator/katran)

### Tools
- [bpftool Reference](https://github.com/libbpf/bpftool)
- [libbpf API](https://libbpf.readthedocs.io/)
- [BTF and CO-RE](https://nakryiko.com/posts/bpf-portability-and-co-re/)

### Books
- *Linux Observability with BPF* by David Calavera & Lorenzo Fontana
- *BPF Performance Tools* by Brendan Gregg

---

## Contributing

### This is Reference Material

These examples were generated by **Claude Sonnet 4.6** as educational content. They demonstrate **patterns and approaches** but are not production-tested.

**How to use this code**:
1. ‚úÖ Learn from it
2. ‚úÖ Copy patterns into your project
3. ‚úÖ Use as a starting point
4. ‚úÖ Adapt to your specific requirements
5. ‚ùå Don't deploy as-is to production without thorough testing

### Improvement Ideas

If you're building on this, consider:

- **Testing**: Add unit tests (BPF mock framework), integration tests (veth pairs)
- **Performance**: Benchmark different map types, optimize loop unrolling
- **Security**: Add input validation, prevent integer overflows
- **Observability**: Add prometheus metrics, structured logging
- **IPv6**: Full dual-stack support
- **Error handling**: Better recovery from map insertion failures
- **Documentation**: Add packet flow diagrams, sequence diagrams

---

## Questions?

This is AI-generated reference material. For real-world problems:
- Ask in [eBPF Slack](https://ebpf.io/slack)
- Post on [eBPF Reddit](https://reddit.com/r/eBPF)
- Check [StackOverflow `bpf` tag](https://stackoverflow.com/questions/tagged/bpf)

**Remember**: Real production systems require testing, security audits, and expertise. Use this as a learning tool, not a deployment artifact.

Happy hacking! üêù